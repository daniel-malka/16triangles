{"ast":null,"code":"// ...\n\nconst draw = () => {\n  const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n  const data = imageData.data;\n  circles.forEach(circle => {\n    const x = Math.round(circle.x);\n    const y = Math.round(circle.y);\n    const radius = Math.round(circle.radius);\n\n    // Check if the circle is large and overlaps more than one background color\n    const hasLargeOverlap = radius > minRadius && checkOverlap(x, y, radius, imageData, bgColors);\n    if (hasLargeOverlap) {\n      // Flip colors where the background colors are split\n      flipColors(x, y, radius, imageData, bgColors);\n    }\n    ctx.beginPath();\n    ctx.arc(x, y, radius, 0, 2 * Math.PI);\n    ctx.strokeStyle = strokeColor;\n    ctx.fillStyle = fillColor;\n    ctx.stroke();\n    ctx.fill();\n  });\n};\nconst checkOverlap = (x, y, radius, imageData, bgColors) => {\n  const data = imageData.data;\n  let numBackgroundColors = 0;\n  for (let dx = -radius; dx <= radius; dx++) {\n    for (let dy = -radius; dy <= radius; dy++) {\n      const pixelX = x + dx;\n      const pixelY = y + dy;\n\n      // Check if the pixel is within the canvas bounds\n      if (pixelX >= 0 && pixelX < canvas.width && pixelY >= 0 && pixelY < canvas.height) {\n        const pixelIndex = (pixelY * imageData.width + pixelX) * 4;\n        const red = data[pixelIndex];\n        const green = data[pixelIndex + 1];\n        const blue = data[pixelIndex + 2];\n        const pixelColor = `rgb(${red}, ${green}, ${blue})`;\n\n        // Check if the pixel color matches any of the background colors\n        if (bgColors.includes(pixelColor)) {\n          numBackgroundColors++;\n\n          // If there are more than one background colors, consider it as large overlap\n          if (numBackgroundColors > 1) {\n            return true;\n          }\n        }\n      }\n    }\n  }\n  return false;\n};\nconst flipColors = (x, y, radius, imageData, bgColors) => {\n  const data = imageData.data;\n  for (let dx = -radius; dx <= radius; dx++) {\n    for (let dy = -radius; dy <= radius; dy++) {\n      const pixelX = x + dx;\n      const pixelY = y + dy;\n\n      // Check if the pixel is within the canvas bounds\n      if (pixelX >= 0 && pixelX < canvas.width && pixelY >= 0 && pixelY < canvas.height) {\n        const pixelIndex = (pixelY * imageData.width + pixelX) * 4;\n        const red = data[pixelIndex];\n        const green = data[pixelIndex + 1];\n        const blue = data[pixelIndex + 2];\n        const pixelColor = `rgb(${red}, ${green}, ${blue})`;\n\n        // Check if the pixel color matches any of the background colors\n        if (bgColors.includes(pixelColor)) {\n          const flippedColor = getFlippedColor(pixelColor);\n          const [flippedRed, flippedGreen, flippedBlue] = getColorComponents(flippedColor);\n\n          // Flip the color of the pixel\n          data[pixelIndex] = flippedRed;\n          data[pixelIndex + 1] = flippedGreen;\n          data[pixelIndex + 2] = flippedBlue;\n        }\n      }\n    }\n  }\n\n  // Update the canvas with the modified pixel data\n  ctx.putImageData(imageData, 0, 0);\n};\nconst getFlippedColor = color => {\n  // Implement your logic to flip the color\n  // For example, if the color is white (#ffffff), flip it to black (#000000)\n  // and vice versa\n  if (color === '#ffffff') {\n    return '#000000';\n  } else if (color === '#000000') {\n    return '#ffffff';\n  } else {\n    // Handle other colors if needed\n    return color;\n  }\n};\nconst getColorComponents = color => {\n  // Convert the color from hexadecimal to RGB components\n  const red = parseInt(color.slice(1, 3), 16);\n  const green = parseInt(color.slice(3, 5), 16);\n  const blue = parseInt(color.slice(5, 7), 16);\n  return [red, green, blue];\n};\n\n// ...","map":{"version":3,"names":["draw","imageData","ctx","getImageData","canvas","width","height","data","circles","forEach","circle","x","Math","round","y","radius","hasLargeOverlap","minRadius","checkOverlap","bgColors","flipColors","beginPath","arc","PI","strokeStyle","strokeColor","fillStyle","fillColor","stroke","fill","numBackgroundColors","dx","dy","pixelX","pixelY","pixelIndex","red","green","blue","pixelColor","includes","flippedColor","getFlippedColor","flippedRed","flippedGreen","flippedBlue","getColorComponents","putImageData","color","parseInt","slice"],"sources":["C:/Users/user/Desktop/CODE/ART/daniel/16TRI/github/16triangles/src/components/Main/Main.js"],"sourcesContent":["// ...\r\n\r\nconst draw = () => {\r\n  const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\r\n  const data = imageData.data;\r\n\r\n  circles.forEach((circle) => {\r\n    const x = Math.round(circle.x);\r\n    const y = Math.round(circle.y);\r\n    const radius = Math.round(circle.radius);\r\n\r\n    // Check if the circle is large and overlaps more than one background color\r\n    const hasLargeOverlap =\r\n      radius > minRadius &&\r\n      checkOverlap(x, y, radius, imageData, bgColors);\r\n\r\n    if (hasLargeOverlap) {\r\n      // Flip colors where the background colors are split\r\n      flipColors(x, y, radius, imageData, bgColors);\r\n    }\r\n\r\n    ctx.beginPath();\r\n    ctx.arc(x, y, radius, 0, 2 * Math.PI);\r\n    ctx.strokeStyle = strokeColor;\r\n    ctx.fillStyle = fillColor;\r\n    ctx.stroke();\r\n    ctx.fill();\r\n  });\r\n};\r\n\r\nconst checkOverlap = (x, y, radius, imageData, bgColors) => {\r\n  const data = imageData.data;\r\n\r\n  let numBackgroundColors = 0;\r\n\r\n  for (let dx = -radius; dx <= radius; dx++) {\r\n    for (let dy = -radius; dy <= radius; dy++) {\r\n      const pixelX = x + dx;\r\n      const pixelY = y + dy;\r\n\r\n      // Check if the pixel is within the canvas bounds\r\n      if (pixelX >= 0 && pixelX < canvas.width && pixelY >= 0 && pixelY < canvas.height) {\r\n        const pixelIndex = (pixelY * imageData.width + pixelX) * 4;\r\n        const red = data[pixelIndex];\r\n        const green = data[pixelIndex + 1];\r\n        const blue = data[pixelIndex + 2];\r\n        const pixelColor = `rgb(${red}, ${green}, ${blue})`;\r\n\r\n        // Check if the pixel color matches any of the background colors\r\n        if (bgColors.includes(pixelColor)) {\r\n          numBackgroundColors++;\r\n\r\n          // If there are more than one background colors, consider it as large overlap\r\n          if (numBackgroundColors > 1) {\r\n            return true;\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  return false;\r\n};\r\n\r\nconst flipColors = (x, y, radius, imageData, bgColors) => {\r\n  const data = imageData.data;\r\n\r\n  for (let dx = -radius; dx <= radius; dx++) {\r\n    for (let dy = -radius; dy <= radius; dy++) {\r\n      const pixelX = x + dx;\r\n      const pixelY = y + dy;\r\n\r\n      // Check if the pixel is within the canvas bounds\r\n      if (pixelX >= 0 && pixelX < canvas.width && pixelY >= 0 && pixelY < canvas.height) {\r\n        const pixelIndex = (pixelY * imageData.width + pixelX) * 4;\r\n        const red = data[pixelIndex];\r\n        const green = data[pixelIndex + 1];\r\n        const blue = data[pixelIndex + 2];\r\n        const pixelColor = `rgb(${red}, ${green}, ${blue})`;\r\n\r\n        // Check if the pixel color matches any of the background colors\r\n        if (bgColors.includes(pixelColor)) {\r\n          const flippedColor = getFlippedColor(pixelColor);\r\n          const [flippedRed, flippedGreen, flippedBlue] = getColorComponents(flippedColor);\r\n\r\n          // Flip the color of the pixel\r\n          data[pixelIndex] = flippedRed;\r\n          data[pixelIndex + 1] = flippedGreen;\r\n          data[pixelIndex + 2] = flippedBlue;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // Update the canvas with the modified pixel data\r\n  ctx.putImageData(imageData, 0, 0);\r\n};\r\n\r\nconst getFlippedColor = (color) => {\r\n  // Implement your logic to flip the color\r\n  // For example, if the color is white (#ffffff), flip it to black (#000000)\r\n  // and vice versa\r\n  if (color === '#ffffff') {\r\n    return '#000000';\r\n  } else if (color === '#000000') {\r\n    return '#ffffff';\r\n  } else {\r\n    // Handle other colors if needed\r\n    return color;\r\n  }\r\n};\r\n\r\nconst getColorComponents = (color) => {\r\n  // Convert the color from hexadecimal to RGB components\r\n  const red = parseInt(color.slice(1, 3), 16);\r\n  const green = parseInt(color.slice(3, 5), 16);\r\n  const blue = parseInt(color.slice(5, 7), 16);\r\n\r\n  return [red, green, blue];\r\n};\r\n\r\n// ...\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}