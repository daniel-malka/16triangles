{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\user\\\\Desktop\\\\CODE\\\\ART\\\\daniel\\\\16TRI\\\\github\\\\16triangles\\\\src\\\\components\\\\circles\\\\Circles.js\",\n  _s = $RefreshSig$();\nimport React, { useEffect } from 'react';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst Circles = _ref => {\n  _s();\n  let {\n    size,\n    canvasRef\n  } = _ref;\n  const minRadius = 1;\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    const ctx = canvas.getContext('2d');\n    canvas.width = size > 1440 ? 800 : size < 800 ? size / 2 : size < 600 && size - 20;\n    canvas.height = size > 1440 ? 800 : size < 800 ? size / 2 : size < 600 && size - 20;\n    const drawCircles = () => {\n      const totalCircles = 2000;\n      let createCircleAttempts = 500; // Changed to let\n\n      const widthX = canvas.width;\n      const maxRadius = widthX;\n      const circles = [];\n      const doesCircleHaveACollision = circle => {\n        // Check for collision with other circles\n        for (let i = 0; i < circles.length; i++) {\n          const existingCircle = circles[i];\n          const dx = circle.x - existingCircle.x;\n          const dy = circle.y - existingCircle.y;\n          const distance = Math.sqrt(dx * dx + dy * dy);\n          if (distance <= circle.radius + existingCircle.radius) {\n            return true;\n          }\n        }\n        return false;\n      };\n      const createCircle = () => {\n        const x = Math.random() * maxRadius;\n        const y = Math.random() * maxRadius;\n        const radius = minRadius + Math.random() * (maxRadius - minRadius);\n        const newCircle = {\n          x,\n          y,\n          radius\n        };\n        if (doesCircleHaveACollision(newCircle)) {\n          if (createCircleAttempts > 0) {\n            createCircleAttempts--;\n            createCircle();\n          }\n          // Exit if retry limit is reached\n          return;\n        }\n        circles.push(newCircle);\n      };\n      for (let i = 0; i < totalCircles; i++) {\n        createCircle();\n      }\n\n      // Clear the canvas\n      ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n      // Draw circles\n      circles.forEach(circle => {\n        ctx.beginPath();\n        ctx.arc(circle.x, circle.y, circle.radius, 0, 2 * Math.PI);\n        ctx.strokeStyle = 'white';\n        ctx.fillStyle = 'white';\n        ctx.fill();\n      });\n    };\n\n    // Draw circles\n    drawCircles();\n\n    // Event listener for canvas click\n    const handleCanvasClick = () => {\n      drawCircles();\n    };\n    canvas.addEventListener('click', handleCanvasClick);\n\n    // Clean up the event listener\n    return () => {\n      canvas.removeEventListener('click', handleCanvasClick);\n    };\n  }, [canvasRef, size]);\n  return /*#__PURE__*/_jsxDEV(\"canvas\", {\n    ref: canvasRef\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 90,\n    columnNumber: 10\n  }, this);\n};\n_s(Circles, \"OD7bBpZva5O2jO+Puf00hKivP7c=\");\n_c = Circles;\nexport default Circles;\nvar _c;\n$RefreshReg$(_c, \"Circles\");","map":{"version":3,"names":["React","useEffect","jsxDEV","_jsxDEV","Circles","_ref","_s","size","canvasRef","minRadius","canvas","current","ctx","getContext","width","height","drawCircles","totalCircles","createCircleAttempts","widthX","maxRadius","circles","doesCircleHaveACollision","circle","i","length","existingCircle","dx","x","dy","y","distance","Math","sqrt","radius","createCircle","random","newCircle","push","clearRect","forEach","beginPath","arc","PI","strokeStyle","fillStyle","fill","handleCanvasClick","addEventListener","removeEventListener","ref","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["C:/Users/user/Desktop/CODE/ART/daniel/16TRI/github/16triangles/src/components/circles/Circles.js"],"sourcesContent":["import React, { useEffect } from 'react';\r\n\r\nconst Circles = ({ size, canvasRef }) => {\r\n  const minRadius = 1;\r\n\r\n  useEffect(() => {\r\n    const canvas = canvasRef.current;\r\n    const ctx = canvas.getContext('2d');\r\n\r\n    canvas.width = size > 1440 ? 800 : size < 800 ? size / 2 : size < 600 && size - 20;\r\n    canvas.height = size > 1440 ? 800 : size < 800 ? size / 2 : size < 600 && size - 20;\r\n\r\n    const drawCircles = () => {\r\n      const totalCircles = 2000;\r\n      let createCircleAttempts = 500; // Changed to let\r\n\r\n      const widthX = canvas.width;\r\n      const maxRadius = widthX;\r\n\r\n      const circles = [];\r\n\r\n      const doesCircleHaveACollision = (circle) => {\r\n        // Check for collision with other circles\r\n        for (let i = 0; i < circles.length; i++) {\r\n          const existingCircle = circles[i];\r\n          const dx = circle.x - existingCircle.x;\r\n          const dy = circle.y - existingCircle.y;\r\n          const distance = Math.sqrt(dx * dx + dy * dy);\r\n          if (distance <= circle.radius + existingCircle.radius) {\r\n            return true;\r\n          }\r\n        }\r\n        return false;\r\n      };\r\n\r\n      const createCircle = () => {\r\n        const x = Math.random() * maxRadius;\r\n        const y = Math.random() * maxRadius;\r\n        const radius = minRadius + Math.random() * (maxRadius - minRadius);\r\n\r\n        const newCircle = { x, y, radius };\r\n\r\n        if (doesCircleHaveACollision(newCircle)) {\r\n\r\n          if (createCircleAttempts > 0) {\r\n            createCircleAttempts--;\r\n            createCircle();\r\n          }\r\n          // Exit if retry limit is reached\r\n          return;\r\n        }\r\n\r\n        circles.push(newCircle);\r\n      };\r\n\r\n      for (let i = 0; i < totalCircles; i++) {\r\n        createCircle();\r\n      }\r\n\r\n      // Clear the canvas\r\n      ctx.clearRect(0, 0, canvas.width, canvas.height);\r\n\r\n      // Draw circles\r\n      circles.forEach((circle) => {\r\n        ctx.beginPath();\r\n\r\n        ctx.arc(circle.x, circle.y, circle.radius, 0, 2 * Math.PI);\r\n        ctx.strokeStyle = 'white';\r\n        ctx.fillStyle = 'white';\r\n        ctx.fill();\r\n      });\r\n    };\r\n\r\n    // Draw circles\r\n    drawCircles();\r\n\r\n    // Event listener for canvas click\r\n    const handleCanvasClick = () => {\r\n      drawCircles();\r\n    };\r\n\r\n    canvas.addEventListener('click', handleCanvasClick);\r\n\r\n    // Clean up the event listener\r\n    return () => {\r\n      canvas.removeEventListener('click', handleCanvasClick);\r\n    };\r\n  }, [canvasRef, size]);\r\n\r\n  return <canvas ref={canvasRef} />;\r\n};\r\n\r\nexport default Circles;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}